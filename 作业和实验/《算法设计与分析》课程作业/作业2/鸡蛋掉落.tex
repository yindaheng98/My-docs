% !TeX root = ./homework.tex
\section{鸡蛋掉落}
\subsection{问题描述}
\subsubsection*{Description}
你将获得\code{K}个鸡蛋，并可以使用一栋从$1$到$N$共有$N$层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层$F$，满足 $0\leq F\leq N$任何从高于$F$的楼层落下的鸡蛋都会碎，从$F$楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层$X$扔下（满足$1\leq X\leq N$）。

你的目标是确切地知道$F$的值是多少。

无论$F$的初始值如何，你确定$F$的值的最小移动次数是多少？

\subsubsection*{Input}

第一行输入\code{nums}表示有\code{nums}组测试

每组测试输入\code{K}，\code{N}，表示有$K$个鸡蛋，$N$层楼

\subsubsection*{Output}

对每组测试数据，输出确定$F$的最小移动次数

\subsubsection*{Sample Input}

\code{3}

\code{1 2}

\code{2 6}

\code{3 14}

\subsubsection*{Sample Output}

\code{2}

\code{3}

\code{4}

\subsubsection*{提示}
1 <= \code{K} <= 1000

1 <= \code{N} <= 10000

\subsection{算法思路}

设目标值为$x$，要查找的矩阵为$A_{m\times n}=(a_{i,j})$，满足：

$$
\left\{
\begin{aligned}
a_{i,j}\leq a_{i,j+1}&\quad (i\in[1,m],j\in[1,n-1])\\
a_{i,j}\leq a_{i+1,j}&\quad (i\in[1,m-1],j\in[1,n])\\
\end{aligned}
\right.
$$

显然有如下定理：

$$
\begin{aligned}
x>a_{0,n}\Rightarrow(\forall a_{1,j},j\in[1,n])(x>a_{0,j})\\
x<a_{0,n}\Rightarrow(\forall a_{i,n},i\in[1,m])(x>a_{i,n})\\
\end{aligned}
$$

即当目标值大于矩阵右上角值时，目标值必大于矩阵第一行的值；目标值小于矩阵右上角值时，目标值必小于矩阵第一列的值。因此，我们可以从矩阵右上角开始搜索，若目标值较大，则向下搜索；若目标值较小，则向左搜索，直到找到目标值或超出矩阵范围。此算法时间复杂度为$O(m+n)$。

更进一步，对于向下或向左的搜索过程，我们可以使用二分查找，找出当前行不大于目标值的最大元素（目标值较小时）或当前列不小于目标值的最小元素（目标值较大时）。改进后算法的时间复杂度可以达到$O(log(m)+log(n))$。

\subsection{算法伪代码}

见算法\ref{alg:s2}。
\begin{algorithm}[htbp]
\caption{搜索二维矩阵算法伪代码}\label{alg:s2}
\SetKwProg{Fn}{Function}{ begin}{end}
\Fn{FindNumber($A_{m,n}$, $x$)}{
    \KwIn{待查矩阵$A_{m,n}=(a_{i,j})$、目标值$x$}
	\KwOut{$A_{m,n}$中是否存在$a_{i,j}=x$}
	\lIf{$m=0\vee n=0$}{\Return false}
	\lIf{$x=a_{1,n}$}{\Return true}
	\eIf{$x>a_{1,n}$}{
		二分查找满足条件的$k$：$k>1\wedge a_{k,n}\geq x\wedge a_{k-1,n}< x$\;
		\Return $FindNumber(A'_{k,n}=(a_{i,j})(i\in[k,n],j\in[1,n]),x)$\;
	}{
		二分查找满足条件的$k$：$k>1\wedge a_{1,k}\leq x\wedge a_{1,k+1}> x$\;
		\Return $FindNumber(A'_{m,k}=(a_{i,j})(i\in[1,n],j\in[1,k]),x)$\;
	}
}
\end{algorithm}