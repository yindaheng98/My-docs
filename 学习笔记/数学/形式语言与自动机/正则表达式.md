# 正则表达式

**！！注意[正则语言](./正则语言.md)和正则表达式之间的区别与联系！！**

## 正则表达式的定义

字母表$\Sigma$上的正则表达式以递归方式定义：

1. （基础）空集$\emptyset$是正则表达式，表示空语言
2. （基础）$\bm\varepsilon$是正则表达式，表示语言$\{\varepsilon\}$
3. （基础）$\forall a\in\Sigma$，$\bm a$是正则表达式，表示语言$\{a\}$
4. （递归）如果$\bm r$、$\bm s$都是正则表达式，分别表示语言$L$和$M$，那么：
    * （并运算）$\bm r+\bm s$是正则表达式，表示语言$L\cup M$
    * （连接运算）$\bm r\bm s$是正则表达式，表示语言$LM$
    * （闭包运算）$\bm r^*$是正则表达式，表示语言$L^*$
    * （改变运算优先级）$(\bm r)$是正则表达式，表示语言$L$

## 正则表达式与DFA和正则语言间的等价性

为了简便起见，这里分别证明“任意DFA的语言都可以由一个正则表达式所表示”和“任意正则表达式的语言都可以由一个$\varepsilon$-NFA所识别”。

有了这两条性质，显而易见正则表达式与DFA和正则语言间的等价性：

$$
\begin{aligned}
&
  \left\{\begin{aligned}
    &\text{任意DFA的语言都可以由一个正则表达式所表示}\\
    &\text{任意正则表达式的语言都可以由一个$\varepsilon$-NFA所识别}\\
  \end{aligned}\right.&在下面证明\\
  &\Rightarrow\text{正则表达式与DFA等价}&\text{DFA与}\varepsilon\text{-NFA等价}\\
  &\Rightarrow\text{正则表达式与正则语言等价}&\text{正则语言定义}\\
\end{aligned}
$$

### 任意DFA的语言都可以由一个正则表达式所表示

原命题可以描述为：

$$(\forall A\text{是DFA})(\exists \text{正则表达式}R)(\bm L(A)=\bm L(R))$$

此式显然成立，因为对于任意的语言$L$，我们只需要：

1. $(\forall l=a_1a_2\dots a_n\in L)E_l=\bm{a_1a_2\dots a_n}=\{a_1a_2\dots a_n\}$：用连接运算对语言中的每个字符串构造一个正则表达式
2. $E=\bigcup_{l\in L}E_l=\bigcup_{a_1a_2\dots a_n\in L}\{a_1a_2\dots a_n\}=L$：对所有这些正则表达式进行并运算即可得要构造的语言

DFA的语言当然也能构造出来。

注：实际计算中当然不可能遍历所有字符串，具体使用的构造方法有递归式法、状态消除法等。

### 任意正则表达式的语言都可以由一个$\varepsilon$-NFA所识别

按照正则表达式的定义，用递归的方式进行证明。

对于字母表$\Sigma$上的正则表达式：

1. （基础）正则表达式$\emptyset$对应的$\varepsilon$-NFA显然是对任何输入都不能跳转到接受状态的$\varepsilon$-NFA：
```mermaid
graph TD
q0((q开始))
q1((q接受))
```
1. （基础）正则表达式$\bm\varepsilon$对应的$\varepsilon$-NFA显然是一个空转移就跳转到接受状态的$\varepsilon$-NFA：
```mermaid
graph LR
q0((q开始))--ε-->q1((q接受))
```
2. （基础）$\forall a\in\Sigma$，正则表达式$\bm a=\{a\}$对应的$\varepsilon$-NFA显然是读取字符$a$就跳转到接受状态的$\varepsilon$-NFA：
```mermaid
graph LR
q0((q开始))--a-->q1((q接受))
```
3. （递归）如果$\bm r$、$\bm s$都是正则表达式，分别对应一个$\varepsilon$-NFA，那么可以指定一个起点和终点，其中指定的起点通过空转移到$\varepsilon$-NFA内的起点、$\varepsilon$-NFA内的终点空转移到指定的终点，构造如下$\varepsilon$-NFA：
```mermaid
graph LR
qr0((q开始))--ε-->qr2(r对应的ε-NFA)--ε-->qr1((q接受))
qs0((q开始))--ε-->qs2(s对应的ε-NFA)--ε-->qs1((q接受))
```
那么：
  * （并运算）正则表达式$\bm r+\bm s$等价于并联它们就行：
```mermaid
graph LR
q0((q开始))--ε-->qr2(r对应的ε-NFA)--ε-->q1((q接受))
q0--ε-->qs2(s对应的ε-NFA)--ε-->q1
```
  * （连接运算）正则表达式$\bm r\bm s$等价于串联它们：
```mermaid
graph LR
q0((q开始))--ε-->qr2(r对应的ε-NFA)--ε-->q((q))--ε-->qs2(s对应的ε-NFA)--ε-->q1((q接受))
```
  * （闭包运算）正则表达式$\bm r^*$等价于首尾相连：
```mermaid
graph LR
q0((q开始))--ε-->qr2(r对应的ε-NFA)--ε-->q1((q接受))
q1--ε-->q0
```
  * （改变运算优先级）正则表达式$(\bm r)$等价于原$\varepsilon$-NFA不变。

由此，所有的正则表达式均可一步步构造出一个$\varepsilon$-NFA进行表示，原命题得证。

## 正则表达式的运算规则

### 运算优先级定义

括号>闭包运算>连接运算>并运算。例如$\bm{1}+\bm{01^*}=\bm 1+(\bm 0(\bm 1^*))$

### 一些正则表达式计算规则

$$
\begin{aligned}
    \text{并运算}&\\
    &\text{结合律}&\bm{(r+s)+t}&=\bm{r+(s+t)}\\
    &\text{交换律}&\bm{r+s}&=\bm{s+r}\\
    &\text{幂等律}&\bm{r+r}&=\bm{r}\\
    &\text{单位元}\emptyset&\emptyset+\bm{r}&=\bm{r}+\emptyset=\bm{r}\\
    \text{连接运算}&\\
    &\text{结合律}&\bm{(rs)t}&=\bm{r(st)}\\
    &\text{单位元}\bm\varepsilon&\bm{r}\bm\varepsilon&=\bm\varepsilon\bm{r}\\
    &\text{零元}\emptyset&\bm{r}\emptyset&=\emptyset\bm{r}=\emptyset\\
    &&\bm{rs}&\not =\bm{sr}\\
    \text{分配律}&\\
    &\text{左分配律}&\bm{r(s+t)}&=\bm{rs+rt}\\
    &\text{右分配律}&\bm{(r+s)t}&=\bm{rt+st}\\
    \text{闭包运算}&\\
    &&(\bm{r}^*)^*&=\bm{r}^*\\
    &&\emptyset^*&=\bm\varepsilon\\
    &&\bm\varepsilon^*&=\bm\varepsilon\\
    &&\bm r^*&=\bm{r^++\varepsilon}\\
    &&(\bm{\varepsilon+r})^*&=\bm r^*\\
\end{aligned}
$$

### 一些化简规则

$$
\begin{aligned}
    (\bm{\varepsilon+r})\bm r^*&=\bm r^*\\
    \bm{r+rs}^*&=\bm{rs}^*\\
\end{aligned}
$$

### 示例

$E$|$\bm L(E)$
-|-
$\bm a+\bm b$|$\{a\}\cup\{b\}=\{a,b\}$
$(\bm a+\bm b)(\bm a+\bm b)$|$\{a,b\}\{a,b\}=\{aa,ab,ba,bb\}$
$(\bm a+\bm b)^*(\bm{aa}+\bm{bb})$|$\{a,b\}^*\{aa,bb\}=\{\text{以}aa\text{或}bb\text{结尾的字符串}\}$
$\bm{1}+\bm{01^*}$|$\{\varepsilon,1,01,0101,010101,\dots\}$
$(\bm{0+1})^*\bm{01}$|$\{w\in\{0,1\}^*\mid w\text{以}01\text{结尾}\}$
$\bm{01}(\bm{0+1})^*+(\bm{0+1})^*\bm{01}$|$\{w\in\{0,1\}^*\mid w\text{以}01\text{开头}\text{或以}01\text{结尾}\}$
$(\bm{0+1})^*(\bm{1}+\bm{10}+\bm{100})$|$\{w\in\{0,1\}^*\mid w\text{最后三个字符至少有一个是1}\}$

## 正则语言的必要条件：泵引理

对于任意正则语言，总能找到一个正整数$N$（泵长度），该语言中所有长度大于$N$的字符串$w$可以分为$w=xyz$三部分，其中中间的$y$满足：
* $y$非空
* $y$在前$N$个字符内
* $y$可以不断重复而产生新串$xy^kz$，且产生的所有串都仍然属于该语言

（理解“泵”：通过中间的字符串$y$不断产生新串，就像泵一样）

$$
L\text{是正则语言}\Rightarrow(\exist N\in\mathbb N_+)(\forall w\in L)(|w|\geq N\rightarrow(\exist y\not =\varepsilon,|xy|<N)(\forall k\geq 0)(xy^kz\in L))
$$

### 证明

令$N$为DFA$A$的状态数，$L=\bm L(A)$，分两种情况讨论：

#### **1'** $(\forall w\in L)(|w|<N)$

显然$(|w|\geq N\rightarrow(\exist y\not =\varepsilon,|xy|<N)(\forall k\geq 0)(xy^kz\in L))$成立，因为没有$|w|\geq N$的情况

#### **2'** $(\exist w\in L)(|w|\geq N)$

1. 任取一个$|w|\geq N$
2. 设$m=|w|,w=a_1a_2\dots a_m$，令$q_i=\hat\delta(q_0,a_1a_2\dots a_i)$表示DFA识别此字符串时读入字符$a_i$所到达的状态。
3. 由于$m\geq N$，加上初始状态一共$N+1$个状态，因此必然存在两个状态相等：$(\exist 0\leq i<j\leq N)(q_i=q_j)$
4. 令：
     * $x=a_1a_2\dots a_{i-1}(i\geq 1)$或$x=\varepsilon(i=0)$
     * $y=a_{i}a_{i+1}\dots a_{j}$
     * $z=a_{j+1}a_{j+2}\dots a_{m}(j\leq m-1)$或$x=\varepsilon(j=m)$
5. 由于$q_i=q_j$，因此让DFA在$q_iq_{i+1}\dots q_j$之间不断循环可以对应出无穷多个字符串，即$xy^kz$

泵引理即证。

### 案例

#### 证明语言$L=\sum_{n=0}^\infty\bm 0^n\bm 1^n=\{0^n1^n|n\geq 0\}$不是正则语言

反证法：

1. 假设$L$是正则的，那么它满足泵引理
2. 取$w=0^N1^N\in L$，它显然满足$|w|=2N\geq N$
3. 那么对于$y\not =\varepsilon,|xy|<N$：
    * $y$只能取前$N$项
    * $w=0^N1^N$前$N$项全是1
    * 因此$y=0^m,0<m<N$
4. 那么$xy^2z=0^{N+m}1^N\notin L$矛盾
5. 因此$L$不满足泵引理，不是正则语言

#### 证明语言$L=\sum_{n=0}^\infty\bm 0^n\bm 1^n=\{w|w\text{由数量相等的01构成}\}$不是正则语言

同理，用反证法：

1. 假设$L$是正则的，那么它满足泵引理
2. 取$w=0^N1^N\in L$，它显然满足$|w|=2N\geq N$
3. 同理可以引出$xy^2z=0^{N+m}1^N\notin L$矛盾
5. 因此$L$不满足泵引理，不是正则语言

#### 证明语言$L=\sum_{n=0}^\infty\bm 0^n\bm 1^n=\{0^i1^j|i>j\}$不是正则语言

同理，用反证法：

1. 假设$L$是正则的，那么它满足泵引理
2. 取$w=0^{N+1}1^N\in L$，它显然满足$|w|=2N+1\geq N$
3. 同理可以引出$y=0^m,0<m<N$
4. 那么$xy^0z=0^{N+1-m}1^N\notin L$矛盾
5. 因此$L$不满足泵引理，不是正则语言

### $\sum_{n=0}^\infty\bm 0^n\bm 1^n$和$\sum_{n=0}^{100}\bm 0^n\bm 1^n$：由非正则语言引发的思考

由上面的第一个案例可知$\sum_{n=0}^\infty\bm 0^n\bm 1^n$不是正则语言，而对于语言$\sum_{n=0}^{100}\bm 0^n\bm 1^n$，$\sum_{n=0}^{100}\bm 0^n\bm 1^n$本身就是它的正则表达式，它是正则语言。

由此我们可以直觉上感觉到DFA的和正则语言的能力限制：“有穷自动机”的“有穷”决定了有穷自动机只能保存有限个状态，而$\sum_{n=0}^\infty\bm 0^n\bm 1^n$这类语言**要求自动机记住无穷多个“状态”**（记住$0$的数量并将之与$1$的数量进行比较，数量最多可以是无穷多个），因此有穷自动机不能识别。

另外，对于字符串数量有限的语言，必定$(\exist N\in\mathbb N_+)(\forall w\in L)(|w|<N)$，即泵引理必然成立，而其自身也总可以表示为有限个正则表达式的和，因此字符串数量有限的语言必然是正则语言，更加印证了我们对有穷自动机中“有穷”的直觉把握。

那么与有穷自动机相对的，是否存在“无穷自动机”？请见[下推自动机](./下推自动机.md)。